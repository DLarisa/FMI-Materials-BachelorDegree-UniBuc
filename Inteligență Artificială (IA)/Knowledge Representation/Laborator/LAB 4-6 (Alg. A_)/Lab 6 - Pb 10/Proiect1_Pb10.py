# -*- coding: utf-8 -*-
"""Proiect 1.ipynb

Automatically generated by Colaboratory.

Problema 10: Problema Plăcuțelor Colorate
"""

"Librarii"
import time   # pentru timpul de execuție
from copy import deepcopy # ca atunci când facem copii, originalul să nu fie modificat de schimbările din copie
from math import inf # infinit
from collections import defaultdict  # ca să avem un dicționar cu key = sub formă de grilă (nodul meu) și valoarea să fie f-ul
from heapq import heappush, heappop  # coadă de priorități (la bază heap) ---> pt optimizare pt că se sortează automat (rădăcina este nodul minim)




"----------------------------------------------------------------------------------"
"Euristici"

# Euristica Neadmisibilă
# h: câte celule are grila (fie ele cu litere sau goale)
# Nu îndeplinește condiția de admisibilitate pt că h^ >= h  --->  ar însemna ca tabla să nu aibă decât litere diferite și deloc zone cu mai mult de 3 celule colorate identic
# Nu îndeplinește nici condiția de consistență (evident -> o mutare are costul >= 1)
def euristica1(grila):
    nr = 0
    for linie in grila:
        for celula in linie:
          nr += 1

    return nr


# Euristici Admisibile

# h: câte culori au rămas pe grila de joc
# Este admisibilă pentru că trebuie să folosim o mutare pt fiecare culoare
# Deci, îndeplinește condiția de admisibilitate și pe cea de consistență
def euristica2(grila):
    zone = selectare_zone(grila)
    nr_culori = set() # folosim set ca să nu se repete culorile ---> h^ <= h
    for culoare, lista in zone:
      nr_culori.add(culoare)
    return len(nr_culori)


# h: nr_celule_grilă(care nu sunt goale)/nr_zone
# h^ <= h (Evident; într-un fel se realizează o repartiție uniformă a tablei de joc și se aproximează cam câte mutări ar fi necesare) 
# Condiția de consistență e îndeplinită pt că la h^(fiu) avem mai puține zone și litere cu care lucrăm 
def euristica3(grila):
    nr_celule = 0
    for linie in grila:
      for celula in linie:
        if(celula != '#'):    # considerăm doar celulele colorate 
          nr_celule += 1
    
    if(nr_celule == 0):     # ca să evităm împărțirea la 0
      return 0
    
    zone = selectare_zone(grila)
    return len(zone) / nr_celule
    



"----------------------------------------------------------------------------------"
"Funcții Pentru Procesare Grilă"

# Selectare Zone de pe Grilă (inputul nostru)
def selectare_zone(grila):

    linii = len(grila)

    # Dacă grila este goală
    if linii == 0:
        return []

    coloane = len(grila[0])

    # Creăm o matrice cu valori False pentru a ține evidența celulelor vizitate
    vizitat_matrice = []
    for i in range(linii):
      linia = []
      for j in range(coloane):
        linia.append(False)
      vizitat_matrice.append(linia)



    def vizitat(i, j):  # Funcție Recursivă ca să iau toată zona posibilă a culorii (stânga-drapta; sus-jos; NU DIAGONALĂ)
        zona = [(i, j)] #listă de tupluri

        # i/j să nu iasă din range, celula să nu fi fost vizitată și precedent, și celulele să aibă aceeași culoare -> Celula devine True și o adaug la zonă
        if((i > 0) and (vizitat_matrice[i - 1][j] == False) and (grila[i][j] == grila[i - 1][j])):
            vizitat_matrice[i - 1][j] = True
            zona += vizitat(i - 1, j)

        if((i < linii - 1) and (vizitat_matrice[i + 1][j] == False) and (grila[i][j] == grila[i + 1][j])):
            vizitat_matrice[i + 1][j] = True
            zona += vizitat(i + 1, j)

        if((j > 0) and (vizitat_matrice[i][j - 1] == False) and (grila[i][j] == grila[i][j - 1])):
            vizitat_matrice[i][j - 1] = True
            zona += vizitat(i, j - 1)

        if((j < coloane - 1) and (vizitat_matrice[i][j + 1] == False) and (grila[i][j] == grila[i][j + 1])):
            vizitat_matrice[i][j + 1] = True
            zona += vizitat(i, j + 1)

        return zona


    # Selectăm zonele de culori diferite de pe Grila de Joc
    zone = []  # Listă de Tupluri de forma  (culoare = literă, Zona culorii = listă de tupluri)
    for linie in range(linii):
        for coloana in range(coloane):
            if(vizitat_matrice[linie][coloana] == True):  # Ignorăm -> deja vizitat
                continue

            vizitat_matrice[linie][coloana] = True  # Celulă Nouă, nevizitată
            zona = vizitat(linie, coloana)
            zona_culoare = grila[linie][coloana]

            if zona_culoare == '#':  # Ignorăm Zonele Goale
                continue

            zone.append((zona_culoare, zona))


    return zone



# Ștergere Zone Goale + Shiftare
# Parametrii: grila și zona pe care am marcat-o
def stergere(grila, zona):

    # Marcăm Zona Selectată ca fiind Goală
    for (linie, coloana) in zona:
        grila[linie][coloana] = '#'

    linii = len(grila)
    coloane = len(grila[0])

    coloana = 0
    # Primul Pas este să shiftăm în jos celulele (adică să simulăm cum pică culorile după ce am selectat o zonă în interiorul grilei și sunt litere deasupra)
    while(coloana < coloane):
        # Începem de jos în sus (la linii)
        linie = linii - 1
        while(linie > 0):
            # dacă am găsit un #, verificăm dacă mai sunt litere pe aceea coloană și dacă da, facem un "swap" -> ca să pice litera
            if(grila[linie][coloana] == '#'):
                aux = linie - 1
                while(aux >= 0 and grila[aux][coloana] == '#'):
                    aux -= 1

                # nu am mai găsit nicio litera pe coloana noastră, deci nu tb să facem un "swap" căci rămân doar # și literele în partea de jos a grilei
                # asta înseamnă că am terminat cu coloana noastră (am găsit toate literele care mai atârnau în aer) și putem să trecem la alta
                if aux < 0:
                    break

                # dacă am găsit o literă, facem un "swap" între literă și #
                grila[linie][coloana] = grila[aux][coloana]
                grila[aux][coloana] = '#'

            # așa ne asigurăm că vom lua toate literele care mai se află în aer (programul se asigură că pe coloană, de la o anumită linie până la înalțimea maximă a grilei, nu există decât #)
            linie -= 1

        # Ștergem Coloane Goale (care au doar #) -> baza grilei (linia = n-1) are # pe coloana noastră
        if grila[linii - 1][coloana] == '#':
            for linie in range(linii):
                del grila[linie][coloana] # ștergem fiecare celulă pe rând
            coloane -= 1 # micșorăm nr de coloane și nu tb să mai facem coloana++ pt ca altfel sărim peste o coloană
        else:  # dacă nu avem coloana goală, atunci trecem la coloana următoare și dăm instrucțiunea manual
            coloana += 1


    # Ștergem Linii Goale
    linie = 0
    while(linie < linii):
        # Ne asigurăm că toate celulele de pe linie sunt goale
        ok = True
        for coloana in range(coloane):
          if(grila[linie][coloana] != '#'): # înseamnă că am găsit o litera, deci nu putem șterge linia
            ok = False
            break

        if(ok == True): # Linia este goală -> putem să micșorăm nr de linii din grilă și nu tb să mai facem linie++ pt ca altfel sărim peste o linie
          del grila[linie]
          linii -= 1
        else: # trecem la următoarea linie
          linie +=1




"----------------------------------------------------------------------------------"
"Clasa Nod A*"

class NodParcurgere:

    def __init__(self, grila, g = 0, parinte = None, f = None):
        self.grila = grila
        self.parinte = parinte
        self.g = g
        self.h = euristica(grila)

        if f is None:
          self.f  = self.g + self.h
        else:
          self.f = f


    def drum_arbore(self):
        # Recrează drumul de la nod până la rădăcină, apoi inversăm drumul ca să putem afișa în ordine 
        nod = self
        drum = [nod] 
        while nod.parinte is not None:
            drum += [nod.parinte]
            nod = nod.parinte
        return list(reversed(drum)) # afișare corectă (rădăcină -> final)
    

    # Returnează succesorii nodului selectat
    def expandeaza(self):
        succesori = []
        zone = selectare_zone(self.grila)

        # am creat listă de lungime max = nr litere alfabet
        nr_litere = [0] * 27
        for culoare, zona in zone:
            nr_litere[ord(culoare) - ord('a')] += len(zona)

        # Vecini sunt toate posibilitățile de grile cu o anumită zonă ștearsă din ele
        for culoare, zona in zone:
            nr_litere_zona = len(zona)

            # Luăm în considerare doar blocurile care au mai mult de 3 celule, altfel skip
            if nr_litere_zona < 3:
                continue

            grila_copie = deepcopy(self.grila) # grilă este listă de liste; dacă facem copy() simplu, originalul va reflecta modificările din copie ---> de aceea folosim deepcopy
            stergere(grila_copie, zona) 

            # Calculăm costul, aka g-ul propriu-zis și așa le avem deja inițializate (și g și f) ---> Nu tb să mai fac asta în a*
            cost = 1 + (nr_litere[ord(culoare) - ord('a')] - nr_litere_zona) / nr_litere[ord(culoare) - ord('a')]
            succesori.append(NodParcurgere(grila_copie, self.g + cost, parinte=self))

        return succesori


    def test_scop(self):
        "Scopul este ca grila să fie goală (să nu mai aibă blocuri de culori)"
        return len(self.grila) == 0


    # Afișare formatată
    def __str__(self):
        return '\n'.join(''.join(linie) for linie in self.grila)
    

    # Overload comparație  ---> crescător după f, descrescător după g 
    def __lt__(self, other):
        if(self.f == other.f):
          return self.g > other.g
        return self.f < other.f




"----------------------------------------------------------------------------------"
"Algoritm A*"

def a_star(grila, output):

    rad_arbore = NodParcurgere(grila)
    open_noduri = [rad_arbore]
    # dicționar cu valorile egale cu +inf și cheile pot fi grile acum (vom reține g-ul în el)
    distanta_min = defaultdict(lambda: +inf)

    while open_noduri:
        # selectăm rădăcina heap-ului, deci nodul cu f-ul cel mai mic
        nod_curent = heappop(open_noduri)

        # dacă nodul (a.k.a grila) este gol -> STOP
        if nod_curent.test_scop():
            break

        # Reactualizez lista open de fiecare dată când grila scoate un cost mai bun
        for nod_succesor in nod_curent.expandeaza():
            if nod_succesor.g < distanta_min[nod_succesor]:
                distanta_min[nod_succesor] = nod_succesor.g
                heappush(open_noduri, nod_succesor)


    # Dacă grila este rezorvabilă (adică este goală) -> afișăm configurația
    if nod_curent.test_scop():
        drum = nod_curent.drum_arbore()

        # Cost Total configurație
        total = 0
        for nod in drum[1:]:
            cost = nod.g - nod.parinte.g
            total += cost

        # SCRIERE ÎN FIȘIER
        with open(output, "a") as fout:
          fout.write("Cost Total: %s.\n\n" % str(round(total, 2))) # aproximez la 2 zecimale
          fout.write(str(drum[0]) + "\n\n")

          for nod in drum[1:]:     # ca să avem costul pe fiecare pas (așa cum e cerut în PDF)
            cost = nod.g - nod.parinte.g
            fout.write(str(nod) + "\n")
            fout.write("Cost Mutare: %s.\n\n" % str(round(cost, 2)))   
        fout.close()

    else:
      # SCRIERE ÎN FIȘIER
        with open(output, "a") as fout:
          fout.write("Nu există Rezolvare.\n\n")
        fout.close()




"----------------------------------------------------------------------------------"
"Funcție Pentru Citire Input"

# Intorce Grila Jocului. Ex: [['a', 'a', 'a', 'a'], ['b', 'b', 'b', 'b'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['b', 'b', 'b', 'b']]
def citire(path):
    with open(path) as fin:
        grila = []
        for linie in fin:
            rand = list(linie.strip()) #crează listă din fiecare linie a grilei mele. Ex: ['a', 'a', 'a', 'a']
            grila.append(rand)
        return grila




"----------------------------------------------------------------------------------"
"Main"

global euristica # variabila globala pentru ca o folosesc in alte functii

if __name__ == '__main__':
    for i in range(1, 5):     # i = {1, 2, 3, 4}

        # Fisiere Intrare + Ieșire
        fin = "input_" + str(i) + ".txt"     # fișier input
        fout = "output_" + str(i) + ".txt"   # fișier output 


        # SCRIEM IN FISIERUL DE IESIRE
        with open(fout, "w") as WRITE:
          WRITE.write("Input " + str(i) + '\n\n\n')
          WRITE.close()


        # Citire stare initiala (am initializat grila cu ce avem in fisiere)
        grila = citire(fin)   


        # SCRIEM IN FISIERUL DE IESIRE -> Eurisitica 1
        with open(fout, "a") as WRITE:
          WRITE.write("Euristica 1 (Nu e Admisibilă):\n")
          WRITE.close()

        start_time = time.time()  # START TIME EXECUȚIE

        euristica = euristica1
        a_star(grila, fout)

        with open(fout, "a") as WRITE:   #STOP TIME EXECUȚIE
          WRITE.write("\nAlgoritmul A* s-a terminat în: %s secunde.\n\n\n\n" % round((time.time() * 100 - start_time * 100), 2))
          WRITE.close()




        # SCRIEM IN FISIERUL DE IESIRE -> Eurisitica 2
        with open(fout, "a") as WRITE:
          WRITE.write("Euristica 2:\n")
          WRITE.close()
        
        start_time = time.time()  # START TIME EXECUȚIE

        euristica = euristica2
        a_star(grila, fout)

        with open(fout, "a") as WRITE:   #STOP TIME EXECUȚIE
          WRITE.write("\nAlgoritmul A* s-a terminat în: %s secunde.\n\n\n\n" % round((time.time() * 100 - start_time * 100), 2))
          WRITE.close()




        # SCRIEM IN FISIERUL DE IESIRE -> Eurisitica 3
        with open(fout, "a") as WRITE:
          WRITE.write("Euristica 3:\n")
          WRITE.close()
        
        start_time = time.time()  # START TIME EXECUȚIE

        euristica = euristica3
        a_star(grila, fout)
        
        with open(fout, "a") as WRITE:   #STOP TIME EXECUȚIE
          WRITE.write("\nAlgoritmul A* s-a terminat în: %s secunde.\n\n\n\n" % round((time.time() * 100 - start_time * 100), 2))
          WRITE.close()