# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.
"""

from copy import deepcopy
from enum import Enum


INF = 2 ** 50

class Patrat(Enum):
    EMPTY = 0
    BLACK = 1
    WHITE = 2

    def opus(self):
        if self == self.BLACK:
            return self.WHITE
        elif self == self.WHITE:
            return self.BLACK
        else:
            raise RuntimeError("Eroare.")


    def is_maximizing(self):
        return self == self.BLACK

    def __str__(self):
        if self == self.BLACK:
            return '░'
        elif self == self.WHITE:
            return '█'
        else:
            return ' '


def is_within_bounds(rand, coloana):
    return 0 <= rand <= 7 and 0 <= coloana <= 7


def semn(x):
    if x < 0:
        return -1
    elif x == 0:
        return 0
    else:
        return 1



class Config:

    def __init__(self, board):
        self.board = board

    @staticmethod
    def initial():
        board = [
            [Patrat.EMPTY for _ in range(8)]
            for _ in range(8)
        ]

        board[3][3] = Patrat.WHITE
        board[3][4] = Patrat.BLACK

        board[4][3] = Patrat.BLACK
        board[4][4] = Patrat.WHITE

        return Config(board)

    def possible_moves(self, color):
        moves = []

        for rand in range(8):
            for coloana in range(8):
                if self.board[rand][coloana] == Patrat.EMPTY:
                    ends = self.is_valid(color, rand, coloana)
                    if ends:
                        point = (rand, coloana)
                        moves.append((point, ends))

        return moves


    def is_valid(self, color, rand, coloana):
        opus_culoare = color.opus()
        ends = []
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1), (0, 1),
            (1, -1), (1, 0), (1, 1),
        ]

        for direction in directions:
            di, dj = direction

            i, j = rand + di, coloana + dj
            if is_within_bounds(i, j):
                piece = self.board[i][j]

                if piece == Patrat.EMPTY:
                    continue

                if piece == color:
                    continue

                while is_within_bounds(i, j) and self.board[i][j] == opus_culoare:
                    i += di
                    j += dj

                if is_within_bounds(i, j) and self.board[i][j] == color:
                    ends.append((i, j))
        return ends


    def make_move(self, color, rand, coloana, endpoints):
        new_board = deepcopy(self.board)

        for end_i, end_j in endpoints:
            di, dj = semn(end_i - rand), semn(end_j - coloana)
            i, j = rand, coloana

            while i != end_i or j != end_j:
                new_board[i][j] = color

                i += di
                j += dj

        return Config(new_board)


    def count_stones(self, color):
        count = 0

        for rand in self.board:
            for piece in rand:
                if piece == color:
                    count += 1

        return count


    def __repr__(self):
        s = '  '
        for digit in range(8):
            s += str(digit) + ' '
        s += '\n'
        for index, rand in enumerate(self.board):
            s += str(index) + ' '
            for coloana in rand:
                s += str(coloana) + ' '
            s += '\n'
        return s


def minimax(config, player, depth, alpha=-INF, beta=+INF):

    if depth == 0:
        return config.count_stones(Patrat.BLACK)

    other_player = player.opus()

    next_moves = config.possible_moves(player)

    if player.is_maximizing():
        score = -INF
    else:
        score = +INF

    for (rand, coloana), ends in next_moves:
        next_config = config.make_move(player, rand, coloana, ends)
        value = minimax(next_config, other_player, depth - 1, alpha, beta)

        if player.is_maximizing():
            score = max(score, value)
            alpha = max(alpha, value)
        else:
            score = min(score, value)
            beta = min(beta, value)

        if alpha >= beta:
            break

    return score





print("=== REVERSI ===")
# 1 for Black
# 2 for White
HUMAN_COLOR = 1

# Max depth for algorithm
MAX_DEPTH = 5


human_player = Patrat(HUMAN_COLOR)
computer_player = human_player.opus()
current_config = Config.initial()
current_player = Patrat.BLACK


while True:
    moves = current_config.possible_moves(current_player)

    if not moves:
        print("Joc Pierdut!")

        human_pieces = current_config.count_stones(human_player)
        computer_pieces = current_config.count_stones(computer_player)

        if human_pieces > computer_pieces:
            print(f"Jucător {human_player} câștigă!")
        else:
            print(f" {computer_player} câștigă!")

        break

    if current_player == human_player:
        print(current_config)

        print("Mutare:")
        try:
            rand, coloana = map(int, input("Rând, Coloana: ").split())
        except ValueError:
            print("Combinație invalidă de comenzi. Încearcă din nou!")
            continue

        ends = current_config.is_valid(human_player, rand, coloana)

        if not ends:
            print("Eroare!")
            continue

        current_config = current_config.make_move(human_player, rand, coloana, ends)
    else:
        configs = [
            current_config.make_move(computer_player, rand, coloana, ends)
            for (rand, coloana), ends in moves
        ]

        moves_and_configs = zip(moves, configs)
        def score_move_and_config(params):
            _, config = params
            return minimax(config, computer_player, MAX_DEPTH)

        if computer_player.is_maximizing():
            func = max
        else:
            func = min

        best_move, best_config = func(moves_and_configs, key=score_move_and_config)

        position, _ = best_move
        print(f"Computerul pune piesa pe poziția: {position}")

        current_config = best_config

    current_player = current_player.opus()