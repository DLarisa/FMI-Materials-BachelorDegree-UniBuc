<?xml version="1.0" encoding="UTF-8"?>
<!--Designed and generated by Altova StyleVision Enterprise Edition 2011 rel. 3 sp1 - see http://www.altova.com/stylevision for more information.-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:altova="http://www.altova.com" xmlns:altovaext="http://www.altova.com/xslt-extensions" xmlns:clitype="clitype" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:iso4217="http://www.xbrl.org/2003/iso4217" xmlns:ix="http://www.xbrl.org/2008/inlineXBRL" xmlns:java="java" xmlns:link="http://www.xbrl.org/2003/linkbase" xmlns:n1="osdm_a_dt" xmlns:sps="http://www.altova.com/StyleVision/user-xpath-functions" xmlns:xbrldi="http://xbrl.org/2006/xbrldi" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" exclude-result-prefixes="#all">
	<xsl:output version="1.0" method="xml" encoding="UTF-8" indent="no"/>
	<xsl:param name="altova:bGeneratingFromPxf" select="false()"/>
	<xsl:param name="SV_OutputFormat" select="'PDF'"/>
	<xsl:param name="SV_BaseOutputFileName" as="xs:string?">
		<xsl:sequence select="for $i in altovaext:get-base-output-uri(), $j in tokenize( $i, &apos;[/\\]&apos; )[last()] return replace( $j, &apos;\.[^\.\s#%;]*$&apos;, &apos;&apos; )" use-when="function-available(&apos;altovaext:get-base-output-uri&apos;)"/>
	</xsl:param>
	<xsl:param name="SV_GeneratedFileNamePrefix" select="if ( $SV_BaseOutputFileName ) then $SV_BaseOutputFileName else &apos;AllDistinctTypesDetails&apos;" as="xs:string?"/>
	<xsl:variable name="XML" select="/"/>
	<xsl:variable name="fo:layout-master-set">
		<fo:layout-master-set>
			<fo:simple-page-master master-name="page-master-219111216-even" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="even-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-219111216-odd" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="odd-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-219111216-even-first" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="even-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-219111216-odd-first" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="odd-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-219111216-even-last" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="even-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-219111216-odd-last" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="odd-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:page-sequence-master master-name="page-master-219111216">
				<fo:repeatable-page-master-alternatives>
					<fo:conditional-page-master-reference master-reference="page-master-219111216-even-first" odd-or-even="even" page-position="first"/>
					<fo:conditional-page-master-reference master-reference="page-master-219111216-odd-first" odd-or-even="odd" page-position="first"/>
					<fo:conditional-page-master-reference master-reference="page-master-219111216-even-last" odd-or-even="even" page-position="last"/>
					<fo:conditional-page-master-reference master-reference="page-master-219111216-odd-last" odd-or-even="odd" page-position="last"/>
					<fo:conditional-page-master-reference master-reference="page-master-219111216-even" odd-or-even="even"/>
					<fo:conditional-page-master-reference master-reference="page-master-219111216-odd" odd-or-even="odd"/>
				</fo:repeatable-page-master-alternatives>
			</fo:page-sequence-master>
			<fo:simple-page-master master-name="page-master-261112744-even" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="even-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-261112744-odd" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="odd-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-261112744-even-first" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="even-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-261112744-odd-first" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="odd-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-261112744-even-last" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="even-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:simple-page-master master-name="page-master-261112744-odd-last" margin-left="2cm" margin-right="2cm" page-height="21cm" page-width="29.70cm" margin-top="0.7cm" margin-bottom="0.7cm">
				<fo:region-body margin-top="1.30cm" margin-bottom="1.30cm" column-count="1"/>
				<fo:region-after region-name="odd-page-footer" overflow="hidden" extent="1.30cm"/>
			</fo:simple-page-master>
			<fo:page-sequence-master master-name="page-master-261112744">
				<fo:repeatable-page-master-alternatives>
					<fo:conditional-page-master-reference master-reference="page-master-261112744-even-first" odd-or-even="even" page-position="first"/>
					<fo:conditional-page-master-reference master-reference="page-master-261112744-odd-first" odd-or-even="odd" page-position="first"/>
					<fo:conditional-page-master-reference master-reference="page-master-261112744-even-last" odd-or-even="even" page-position="last"/>
					<fo:conditional-page-master-reference master-reference="page-master-261112744-odd-last" odd-or-even="odd" page-position="last"/>
					<fo:conditional-page-master-reference master-reference="page-master-261112744-even" odd-or-even="even"/>
					<fo:conditional-page-master-reference master-reference="page-master-261112744-odd" odd-or-even="odd"/>
				</fo:repeatable-page-master-alternatives>
			</fo:page-sequence-master>
		</fo:layout-master-set>
	</xsl:variable>
	<xsl:variable name="altova:nPxPerIn" select="96"/>
	<xsl:variable name="altova:design-xslt-tree-view">
		<altova:main-document url="{if ($SV_BaseOutputFileName) then concat($SV_BaseOutputFileName,'.fo') else ''}">
			<fo:root>
				<xsl:copy-of select="$fo:layout-master-set"/>
				<fo:declarations>
					<x:xmpmeta xmlns:x="adobe:ns:meta/">
						<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
							<rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
								<xmp:CreatorTool>Altova StyleVision Enterprise Edition 2011 rel. 3 sp1 (http://www.altova.com)</xmp:CreatorTool>
							</rdf:Description>
						</rdf:RDF>
					</x:xmpmeta>
				</fo:declarations>
				<altova:pdf-bookmark-tree generate-from-toc="false">
					<xsl:for-each select="$XML">
						<xsl:for-each select="n1:root">
							<xsl:for-each select="n1:DTCollection">
								<xsl:for-each select="n1:DTDetails">
									<xsl:for-each select="n1:DTName">
										<altova:pdf-bookmark>
											<altova:hyperlink href="{concat(&apos;#&apos;,.)}">
												<altova:inline-container-substitute font-size="xx-small">
													<xsl:apply-templates/>
												</altova:inline-container-substitute>
											</altova:hyperlink>
										</altova:pdf-bookmark>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:for-each>
						<altova:newline-handler/>
					</xsl:for-each>
				</altova:pdf-bookmark-tree>
				<fo:page-sequence master-reference="page-master-219111216" initial-page-number="auto" format="1" altova:DocumentEndsOn="">
					<fo:static-content flow-name="odd-page-footer">
						<fo:block-container height="1.30cm" overflow="hidden" display-align="after">
							<fo:block font-family="Tahoma" font-size="xx-small">
								<xsl:variable name="altova:table">
									<fo:table font-size="xx-small" width="25cm" table-layout="fixed" border-spacing="0">
										<fo:table-column column-width="18cm"/>
										<fo:table-column column-width="7cm"/>
										<xsl:variable name="altova:CurrContextGrid_084B2A18" select="."/>
										<xsl:variable name="altova:ColumnData">
											<altova:Internal/>
										</xsl:variable>
										<fo:table-body start-indent="0pt">
											<fo:table-row>
												<fo:table-cell padding="3" display-align="center">
													<fo:block text-align="left">
														<fo:inline>
															<xsl:text>Oracle Data Modeler</xsl:text>
														</fo:inline>
													</fo:block>
												</fo:table-cell>
												<fo:table-cell padding="3" display-align="center">
													<fo:block text-align="right">
														<fo:inline>
															<xsl:text>Page: </xsl:text>
														</fo:inline>
														<fo:page-number/>
														<fo:inline>
															<xsl:text> / </xsl:text>
														</fo:inline>
														<fo:page-number-citation ref-id="SV_RefID_PageTotal"/>
													</fo:block>
												</fo:table-cell>
											</fo:table-row>
										</fo:table-body>
									</fo:table>
								</xsl:variable>
								<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
							</fo:block>
						</fo:block-container>
					</fo:static-content>
					<fo:static-content flow-name="even-page-footer">
						<fo:block-container height="1.30cm" overflow="hidden" display-align="after">
							<fo:block font-family="Tahoma" font-size="xx-small">
								<xsl:variable name="altova:table">
									<fo:table font-size="xx-small" width="25cm" table-layout="fixed" border-spacing="0">
										<fo:table-column column-width="18cm"/>
										<fo:table-column column-width="7cm"/>
										<xsl:variable name="altova:CurrContextGrid_084B2A18" select="."/>
										<xsl:variable name="altova:ColumnData">
											<altova:Internal/>
										</xsl:variable>
										<fo:table-body start-indent="0pt">
											<fo:table-row>
												<fo:table-cell padding="3" display-align="center">
													<fo:block text-align="left">
														<fo:inline>
															<xsl:text>Oracle Data Modeler</xsl:text>
														</fo:inline>
													</fo:block>
												</fo:table-cell>
												<fo:table-cell padding="3" display-align="center">
													<fo:block text-align="right">
														<fo:inline>
															<xsl:text>Page: </xsl:text>
														</fo:inline>
														<fo:page-number/>
														<fo:inline>
															<xsl:text> / </xsl:text>
														</fo:inline>
														<fo:page-number-citation ref-id="SV_RefID_PageTotal"/>
													</fo:block>
												</fo:table-cell>
											</fo:table-row>
										</fo:table-body>
									</fo:table>
								</xsl:variable>
								<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
							</fo:block>
						</fo:block-container>
					</fo:static-content>
					<fo:flow flow-name="xsl-region-body">
						<fo:block font-family="Tahoma" font-size="xx-small" empty-cells="show" text-align="left" display-align="before">
							<fo:block text-align="center" space-before="0" space-after="0" margin="0pt">
								<fo:inline font-size="medium" font-weight="bold">
									<xsl:text>All Distinct Types Details</xsl:text>
								</fo:inline>
							</fo:block>
							<altova:newline-handler/>
							<xsl:for-each select="$XML">
								<xsl:for-each select="n1:root">
									<altova:newline-handler/>
									<altova:newline-handler/>
									<xsl:variable name="altova:table">
										<fo:table width="20cm" table-layout="fixed" border-spacing="0">
											<fo:table-column column-width="4cm"/>
											<fo:table-column column-width="16cm"/>
											<xsl:variable name="altova:CurrContextGrid_09799D30" select="."/>
											<xsl:variable name="altova:ColumnData">
												<altova:Internal/>
											</xsl:variable>
											<fo:table-body start-indent="0pt">
												<fo:table-row>
													<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
														<fo:block text-align="left">
															<fo:inline>
																<xsl:text>Design Name</xsl:text>
															</fo:inline>
														</fo:block>
													</fo:table-cell>
													<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
														<fo:block text-align="left">
															<xsl:choose>
																<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																	<xsl:for-each select="n1:DesignName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																	<xsl:choose>
																		<xsl:when test="string-length(n1:DesignName) &gt; 0">
																			<xsl:for-each select="n1:DesignName">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<fo:inline>
																				<xsl:text>&#160;</xsl:text>
																			</fo:inline>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																	<xsl:for-each select="n1:DesignName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																	<xsl:for-each select="n1:DesignName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																	<xsl:for-each select="n1:DesignName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
															</xsl:choose>
														</fo:block>
													</fo:table-cell>
												</fo:table-row>
												<fo:table-row>
													<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
														<fo:block text-align="left">
															<fo:inline>
																<xsl:text>Version Date</xsl:text>
															</fo:inline>
														</fo:block>
													</fo:table-cell>
													<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
														<fo:block text-align="left">
															<xsl:choose>
																<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																	<xsl:for-each select="n1:VersionDate">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																	<xsl:choose>
																		<xsl:when test="string-length(n1:VersionDate) &gt; 0">
																			<xsl:for-each select="n1:VersionDate">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<fo:inline>
																				<xsl:text>&#160;</xsl:text>
																			</fo:inline>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																	<xsl:for-each select="n1:VersionDate">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																	<xsl:for-each select="n1:VersionDate">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																	<xsl:for-each select="n1:VersionDate">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
															</xsl:choose>
														</fo:block>
													</fo:table-cell>
												</fo:table-row>
												<fo:table-row>
													<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
														<fo:block text-align="left">
															<fo:inline>
																<xsl:text>Version Comment</xsl:text>
															</fo:inline>
														</fo:block>
													</fo:table-cell>
													<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
														<fo:block text-align="left">
															<xsl:choose>
																<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																	<xsl:for-each select="n1:VersionComment">
																		<xsl:for-each select="n1:VersionCommentDetails">
																			<xsl:for-each select="n1:VersionCommentRow">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																				<altova:newline-handler/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																	<xsl:choose>
																		<xsl:when test="count(n1:VersionComment/n1:VersionCommentDetails/n1:VersionCommentRow) &gt; 0">
																			<xsl:for-each select="n1:VersionComment">
																				<xsl:for-each select="n1:VersionCommentDetails">
																					<xsl:for-each select="n1:VersionCommentRow">
																						<altova:inline-container-substitute>
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																						<altova:newline-handler/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<fo:inline>
																				<xsl:text>&#160;</xsl:text>
																			</fo:inline>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																	<xsl:choose>
																		<xsl:when test="count(n1:VersionComment/n1:VersionCommentDetails/n1:VersionCommentRow) &gt; 0">
																			<xsl:for-each select="n1:VersionComment">
																				<xsl:for-each select="n1:VersionCommentDetails">
																					<xsl:for-each select="n1:VersionCommentRow">
																						<altova:inline-container-substitute>
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																						<altova:newline-handler/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise/>
																	</xsl:choose>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																	<xsl:for-each select="n1:VersionComment">
																		<xsl:for-each select="n1:VersionCommentDetails">
																			<xsl:for-each select="n1:VersionCommentRow">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																				<altova:newline-handler/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																	<xsl:for-each select="n1:VersionComment">
																		<xsl:for-each select="n1:VersionCommentDetails">
																			<xsl:for-each select="n1:VersionCommentRow">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																				<altova:newline-handler/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:when>
															</xsl:choose>
														</fo:block>
													</fo:table-cell>
												</fo:table-row>
												<fo:table-row>
													<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
														<fo:block text-align="left">
															<fo:inline>
																<xsl:text>Model Name</xsl:text>
															</fo:inline>
														</fo:block>
													</fo:table-cell>
													<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
														<fo:block text-align="left">
															<xsl:choose>
																<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																	<xsl:for-each select="n1:ModelName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																	<xsl:choose>
																		<xsl:when test="string-length(n1:ModelName) &gt; 0">
																			<xsl:for-each select="n1:ModelName">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<fo:inline>
																				<xsl:text>&#160;</xsl:text>
																			</fo:inline>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																	<xsl:for-each select="n1:ModelName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																	<xsl:for-each select="n1:ModelName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
																<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																	<xsl:for-each select="n1:ModelName">
																		<altova:inline-container-substitute>
																			<xsl:apply-templates/>
																		</altova:inline-container-substitute>
																	</xsl:for-each>
																</xsl:when>
															</xsl:choose>
														</fo:block>
													</fo:table-cell>
												</fo:table-row>
											</fo:table-body>
										</fo:table>
									</xsl:variable>
									<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
									<xsl:for-each select="n1:DTCollection">
										<xsl:for-each select="n1:DTDetails">
											<altova:newline-handler/>
											<altova:document-section master-reference="page-master-261112744" altova:section-starts-on="next" initial-page-number="auto" format="1">
												<fo:static-content flow-name="odd-page-footer">
													<fo:block-container height="1.30cm" overflow="hidden" display-align="after">
														<fo:block font-family="Tahoma" font-size="xx-small">
															<xsl:variable name="altova:table">
																<fo:table font-size="xx-small" width="25cm" table-layout="fixed" border-spacing="0">
																	<fo:table-column column-width="18cm"/>
																	<fo:table-column column-width="7cm"/>
																	<xsl:variable name="altova:CurrContextGrid_0F850AA0" select="."/>
																	<xsl:variable name="altova:ColumnData">
																		<altova:Internal/>
																	</xsl:variable>
																	<fo:table-body start-indent="0pt">
																		<fo:table-row>
																			<fo:table-cell padding="3" display-align="center">
																				<fo:block text-align="left">
																					<fo:inline>
																						<xsl:text>Oracle Data Modeler</xsl:text>
																					</fo:inline>
																				</fo:block>
																			</fo:table-cell>
																			<fo:table-cell padding="3" display-align="center">
																				<fo:block text-align="right">
																					<fo:inline>
																						<xsl:text>Page: </xsl:text>
																					</fo:inline>
																					<fo:page-number/>
																					<fo:inline>
																						<xsl:text> / </xsl:text>
																					</fo:inline>
																					<fo:page-number-citation ref-id="SV_RefID_PageTotal"/>
																				</fo:block>
																			</fo:table-cell>
																		</fo:table-row>
																	</fo:table-body>
																</fo:table>
															</xsl:variable>
															<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
														</fo:block>
													</fo:block-container>
												</fo:static-content>
												<fo:static-content flow-name="even-page-footer">
													<fo:block-container height="1.30cm" overflow="hidden" display-align="after">
														<fo:block font-family="Tahoma" font-size="xx-small">
															<xsl:variable name="altova:table">
																<fo:table font-size="xx-small" width="25cm" table-layout="fixed" border-spacing="0">
																	<fo:table-column column-width="18cm"/>
																	<fo:table-column column-width="7cm"/>
																	<xsl:variable name="altova:CurrContextGrid_0F850AA0" select="."/>
																	<xsl:variable name="altova:ColumnData">
																		<altova:Internal/>
																	</xsl:variable>
																	<fo:table-body start-indent="0pt">
																		<fo:table-row>
																			<fo:table-cell padding="3" display-align="center">
																				<fo:block text-align="left">
																					<fo:inline>
																						<xsl:text>Oracle Data Modeler</xsl:text>
																					</fo:inline>
																				</fo:block>
																			</fo:table-cell>
																			<fo:table-cell padding="3" display-align="center">
																				<fo:block text-align="right">
																					<fo:inline>
																						<xsl:text>Page: </xsl:text>
																					</fo:inline>
																					<fo:page-number/>
																					<fo:inline>
																						<xsl:text> / </xsl:text>
																					</fo:inline>
																					<fo:page-number-citation ref-id="SV_RefID_PageTotal"/>
																				</fo:block>
																			</fo:table-cell>
																		</fo:table-row>
																	</fo:table-body>
																</fo:table>
															</xsl:variable>
															<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
														</fo:block>
													</fo:block-container>
												</fo:static-content>
											</altova:document-section>
											<xsl:variable name="altova:table">
												<fo:table width="15cm" table-layout="fixed" border-spacing="0">
													<fo:table-column column-width="4cm"/>
													<fo:table-column column-width="11cm"/>
													<xsl:variable name="altova:CurrContextGrid_0F913DE0" select="."/>
													<xsl:variable name="altova:ColumnData">
														<altova:Internal/>
													</xsl:variable>
													<fo:table-body start-indent="0pt">
														<fo:table-row>
															<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																<fo:block text-align="left">
																	<fo:inline>
																		<xsl:text>Distinct Type Name</xsl:text>
																	</fo:inline>
																</fo:block>
															</fo:table-cell>
															<fo:table-cell background-color="#a5e7ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" padding="3" display-align="center">
																<fo:block text-align="left">
																	<fo:block font-size="2em" font-weight="bold" space-before="0.67em" space-after="0.67em" margin="0pt">
																		<altova:bookmark name="{n1:DTName}">
																			<xsl:choose>
																				<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																					<xsl:for-each select="n1:DTName">
																						<altova:inline-container-substitute font-size="xx-small">
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																					<xsl:choose>
																						<xsl:when test="string-length(n1:DTName) &gt; 0">
																							<xsl:for-each select="n1:DTName">
																								<altova:inline-container-substitute font-size="xx-small">
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<fo:inline>
																								<xsl:text>&#160;</xsl:text>
																							</fo:inline>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																					<xsl:for-each select="n1:DTName">
																						<altova:inline-container-substitute font-size="xx-small">
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																					<xsl:for-each select="n1:DTName">
																						<altova:inline-container-substitute font-size="xx-small">
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																					<xsl:for-each select="n1:DTName">
																						<altova:inline-container-substitute font-size="xx-small">
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																			</xsl:choose>
																		</altova:bookmark>
																	</fo:block>
																</fo:block>
															</fo:table-cell>
														</fo:table-row>
														<fo:table-row>
															<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																<fo:block text-align="left">
																	<fo:inline>
																		<xsl:text>Logical Type</xsl:text>
																	</fo:inline>
																</fo:block>
															</fo:table-cell>
															<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
																<fo:block text-align="left">
																	<xsl:choose>
																		<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																			<xsl:for-each select="n1:DTLogicalType">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																			<xsl:choose>
																				<xsl:when test="string-length(n1:DTLogicalType) &gt; 0">
																					<xsl:for-each select="n1:DTLogicalType">
																						<altova:inline-container-substitute>
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<fo:inline>
																						<xsl:text>&#160;</xsl:text>
																					</fo:inline>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																			<xsl:for-each select="n1:DTLogicalType">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																			<xsl:for-each select="n1:DTLogicalType">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																			<xsl:for-each select="n1:DTLogicalType">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																	</xsl:choose>
																</fo:block>
															</fo:table-cell>
														</fo:table-row>
														<fo:table-row>
															<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																<fo:block text-align="left">
																	<fo:inline>
																		<xsl:text>Size</xsl:text>
																	</fo:inline>
																</fo:block>
															</fo:table-cell>
															<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
																<fo:block text-align="left">
																	<xsl:choose>
																		<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																			<xsl:for-each select="n1:DTSize">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																			<xsl:choose>
																				<xsl:when test="string-length(n1:DTSize) &gt; 0">
																					<xsl:for-each select="n1:DTSize">
																						<altova:inline-container-substitute>
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<fo:inline>
																						<xsl:text>&#160;</xsl:text>
																					</fo:inline>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																			<xsl:for-each select="n1:DTSize">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																			<xsl:for-each select="n1:DTSize">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																			<xsl:for-each select="n1:DTSize">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																	</xsl:choose>
																</fo:block>
															</fo:table-cell>
														</fo:table-row>
														<fo:table-row>
															<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																<fo:block text-align="left">
																	<fo:inline>
																		<xsl:text>Precision</xsl:text>
																	</fo:inline>
																</fo:block>
															</fo:table-cell>
															<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
																<fo:block text-align="left">
																	<xsl:choose>
																		<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																			<xsl:for-each select="n1:DTPrecision">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																			<xsl:choose>
																				<xsl:when test="string-length(n1:DTPrecision) &gt; 0">
																					<xsl:for-each select="n1:DTPrecision">
																						<altova:inline-container-substitute>
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<fo:inline>
																						<xsl:text>&#160;</xsl:text>
																					</fo:inline>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																			<xsl:for-each select="n1:DTPrecision">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																			<xsl:for-each select="n1:DTPrecision">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																			<xsl:for-each select="n1:DTPrecision">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																	</xsl:choose>
																</fo:block>
															</fo:table-cell>
														</fo:table-row>
														<fo:table-row>
															<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																<fo:block text-align="left">
																	<fo:inline>
																		<xsl:text>Scale</xsl:text>
																	</fo:inline>
																</fo:block>
															</fo:table-cell>
															<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
																<fo:block text-align="left">
																	<xsl:choose>
																		<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																			<xsl:for-each select="n1:DTScale">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																			<xsl:choose>
																				<xsl:when test="string-length(n1:DTScale) &gt; 0">
																					<xsl:for-each select="n1:DTScale">
																						<altova:inline-container-substitute>
																							<xsl:apply-templates/>
																						</altova:inline-container-substitute>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<fo:inline>
																						<xsl:text>&#160;</xsl:text>
																					</fo:inline>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																			<xsl:for-each select="n1:DTScale">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																			<xsl:for-each select="n1:DTScale">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																			<xsl:for-each select="n1:DTScale">
																				<altova:inline-container-substitute>
																					<xsl:apply-templates/>
																				</altova:inline-container-substitute>
																			</xsl:for-each>
																		</xsl:when>
																	</xsl:choose>
																</fo:block>
															</fo:table-cell>
														</fo:table-row>
													</fo:table-body>
												</fo:table>
											</xsl:variable>
											<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
											<fo:inline>
												<xsl:text>&#160;</xsl:text>
											</fo:inline>
											<xsl:if test="count( n1:DescriptionNotes )">
												<altova:newline-handler/>
												<xsl:for-each select="n1:DescriptionNotes">
													<xsl:variable name="altova:table">
														<fo:table width="20cm" table-layout="fixed" border-spacing="0">
															<fo:table-column column-width="4cm"/>
															<fo:table-column column-width="16cm"/>
															<xsl:variable name="altova:CurrContextGrid_0EA34580" select="."/>
															<xsl:variable name="altova:ColumnData">
																<altova:Internal/>
															</xsl:variable>
															<fo:table-body start-indent="0pt">
																<fo:table-row>
																	<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																		<fo:block text-align="left">
																			<fo:inline>
																				<xsl:text>Description</xsl:text>
																			</fo:inline>
																		</fo:block>
																	</fo:table-cell>
																	<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
																		<fo:block text-align="left">
																			<xsl:choose>
																				<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																					<xsl:for-each select="n1:Description">
																						<xsl:for-each select="n1:DescriptionDetails">
																							<xsl:for-each select="n1:DescriptionRow">
																								<altova:inline-container-substitute>
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																								<altova:newline-handler/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																					<xsl:choose>
																						<xsl:when test="count(n1:Description/n1:DescriptionDetails/n1:DescriptionRow) &gt; 0">
																							<xsl:for-each select="n1:Description">
																								<xsl:for-each select="n1:DescriptionDetails">
																									<xsl:for-each select="n1:DescriptionRow">
																										<altova:inline-container-substitute>
																											<xsl:apply-templates/>
																										</altova:inline-container-substitute>
																										<altova:newline-handler/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<fo:inline>
																								<xsl:text>&#160;</xsl:text>
																							</fo:inline>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																					<xsl:choose>
																						<xsl:when test="count(n1:Description/n1:DescriptionDetails/n1:DescriptionRow) &gt; 0">
																							<xsl:for-each select="n1:Description">
																								<xsl:for-each select="n1:DescriptionDetails">
																									<xsl:for-each select="n1:DescriptionRow">
																										<altova:inline-container-substitute>
																											<xsl:apply-templates/>
																										</altova:inline-container-substitute>
																										<altova:newline-handler/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise/>
																					</xsl:choose>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																					<xsl:for-each select="n1:Description">
																						<xsl:for-each select="n1:DescriptionDetails">
																							<xsl:for-each select="n1:DescriptionRow">
																								<altova:inline-container-substitute>
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																								<altova:newline-handler/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																					<xsl:for-each select="n1:Description">
																						<xsl:for-each select="n1:DescriptionDetails">
																							<xsl:for-each select="n1:DescriptionRow">
																								<altova:inline-container-substitute>
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																								<altova:newline-handler/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:when>
																			</xsl:choose>
																		</fo:block>
																	</fo:table-cell>
																</fo:table-row>
																<fo:table-row>
																	<fo:table-cell background-color="#d9f5ff" border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" font-weight="bold" padding="3" display-align="center">
																		<fo:block text-align="left">
																			<fo:inline>
																				<xsl:text>Notes</xsl:text>
																			</fo:inline>
																		</fo:block>
																	</fo:table-cell>
																	<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="center">
																		<fo:block text-align="left">
																			<xsl:choose>
																				<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																					<xsl:for-each select="n1:Notes">
																						<xsl:for-each select="n1:NotesDetails">
																							<xsl:for-each select="n1:NoteRow">
																								<altova:inline-container-substitute>
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																								<altova:newline-handler/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																					<xsl:choose>
																						<xsl:when test="count(n1:Notes/n1:NotesDetails/n1:NoteRow) &gt; 0">
																							<xsl:for-each select="n1:Notes">
																								<xsl:for-each select="n1:NotesDetails">
																									<xsl:for-each select="n1:NoteRow">
																										<altova:inline-container-substitute>
																											<xsl:apply-templates/>
																										</altova:inline-container-substitute>
																										<altova:newline-handler/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<fo:inline>
																								<xsl:text>&#160;</xsl:text>
																							</fo:inline>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																					<xsl:choose>
																						<xsl:when test="count(n1:Notes/n1:NotesDetails/n1:NoteRow) &gt; 0">
																							<xsl:for-each select="n1:Notes">
																								<xsl:for-each select="n1:NotesDetails">
																									<xsl:for-each select="n1:NoteRow">
																										<altova:inline-container-substitute>
																											<xsl:apply-templates/>
																										</altova:inline-container-substitute>
																										<altova:newline-handler/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise/>
																					</xsl:choose>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																					<xsl:for-each select="n1:Notes">
																						<xsl:for-each select="n1:NotesDetails">
																							<xsl:for-each select="n1:NoteRow">
																								<altova:inline-container-substitute>
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																								<altova:newline-handler/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																					<xsl:for-each select="n1:Notes">
																						<xsl:for-each select="n1:NotesDetails">
																							<xsl:for-each select="n1:NoteRow">
																								<altova:inline-container-substitute>
																									<xsl:apply-templates/>
																								</altova:inline-container-substitute>
																								<altova:newline-handler/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:when>
																			</xsl:choose>
																		</fo:block>
																	</fo:table-cell>
																</fo:table-row>
															</fo:table-body>
														</fo:table>
													</xsl:variable>
													<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
												</xsl:for-each>
											</xsl:if>
											<xsl:if test="count( n1:TablesCollection )">
												<altova:newline-handler/>
												<fo:inline font-size="xx-small" font-style="italic">
													<xsl:text>Used In Tables</xsl:text>
												</fo:inline>
												<xsl:variable name="altova:table">
													<fo:table width="25cm" table-layout="fixed" border-spacing="0">
														<fo:table-column column-width="8cm"/>
														<fo:table-column column-width="8.500cm"/>
														<fo:table-column column-width="8.500cm"/>
														<xsl:variable name="altova:CurrContextGrid_09B59DE0" select="."/>
														<xsl:variable name="altova:ColumnData">
															<altova:Internal/>
														</xsl:variable>
														<fo:table-header background-color="#d9f5ff" start-indent="0pt">
															<fo:table-row>
																<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
																	<fo:block text-align="center">
																		<fo:inline>
																			<xsl:text>Model Name</xsl:text>
																		</fo:inline>
																	</fo:block>
																</fo:table-cell>
																<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
																	<fo:block text-align="center">
																		<fo:inline>
																			<xsl:text>Table Name</xsl:text>
																		</fo:inline>
																	</fo:block>
																</fo:table-cell>
																<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
																	<fo:block text-align="center">
																		<fo:inline>
																			<xsl:text>Column Name</xsl:text>
																		</fo:inline>
																	</fo:block>
																</fo:table-cell>
															</fo:table-row>
														</fo:table-header>
														<fo:table-body start-indent="0pt">
															<xsl:for-each select="n1:TablesCollection">
																<xsl:for-each select="n1:TableDetails">
																	<fo:table-row>
																		<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="before">
																			<fo:block text-align="left">
																				<xsl:choose>
																					<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																						<xsl:for-each select="n1:ModelName">
																							<altova:inline-container-substitute>
																								<xsl:apply-templates/>
																							</altova:inline-container-substitute>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																						<xsl:choose>
																							<xsl:when test="string-length(n1:ModelName) &gt; 0">
																								<xsl:for-each select="n1:ModelName">
																									<altova:inline-container-substitute>
																										<xsl:apply-templates/>
																									</altova:inline-container-substitute>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<fo:inline>
																									<xsl:text>&#160;</xsl:text>
																								</fo:inline>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																						<xsl:for-each select="n1:ModelName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																						<xsl:for-each select="n1:ModelName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																						<xsl:for-each select="n1:ModelName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																				</xsl:choose>
																			</fo:block>
																		</fo:table-cell>
																		<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="before">
																			<fo:block text-align="left">
																				<xsl:choose>
																					<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																						<xsl:for-each select="n1:TableName">
																							<altova:inline-container-substitute>
																								<xsl:apply-templates/>
																							</altova:inline-container-substitute>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																						<xsl:choose>
																							<xsl:when test="string-length(n1:TableName) &gt; 0">
																								<xsl:for-each select="n1:TableName">
																									<altova:inline-container-substitute>
																										<xsl:apply-templates/>
																									</altova:inline-container-substitute>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<fo:inline>
																									<xsl:text>&#160;</xsl:text>
																								</fo:inline>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																						<xsl:for-each select="n1:TableName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																						<xsl:for-each select="n1:TableName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																						<xsl:for-each select="n1:TableName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																				</xsl:choose>
																			</fo:block>
																		</fo:table-cell>
																		<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="before">
																			<fo:block text-align="left">
																				<xsl:choose>
																					<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																						<xsl:for-each select="n1:ColumnName">
																							<altova:inline-container-substitute>
																								<xsl:apply-templates/>
																							</altova:inline-container-substitute>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																						<xsl:choose>
																							<xsl:when test="string-length(n1:ColumnName) &gt; 0">
																								<xsl:for-each select="n1:ColumnName">
																									<altova:inline-container-substitute>
																										<xsl:apply-templates/>
																									</altova:inline-container-substitute>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<fo:inline>
																									<xsl:text>&#160;</xsl:text>
																								</fo:inline>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																						<xsl:for-each select="n1:ColumnName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																						<xsl:for-each select="n1:ColumnName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																						<xsl:for-each select="n1:ColumnName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																				</xsl:choose>
																			</fo:block>
																		</fo:table-cell>
																	</fo:table-row>
																</xsl:for-each>
															</xsl:for-each>
														</fo:table-body>
													</fo:table>
												</xsl:variable>
												<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
											</xsl:if>
											<xsl:if test="count( n1:EntitiesCollection )">
												<altova:newline-handler/>
												<fo:inline font-size="xx-small" font-style="italic">
													<xsl:text>Used In Entities</xsl:text>
												</fo:inline>
												<xsl:variable name="altova:table">
													<fo:table width="25cm" table-layout="fixed" border-spacing="0">
														<fo:table-column column-width="12.500cm"/>
														<fo:table-column column-width="12.500cm"/>
														<xsl:variable name="altova:CurrContextGrid_0DB0E268" select="."/>
														<xsl:variable name="altova:ColumnData">
															<altova:Internal/>
														</xsl:variable>
														<fo:table-header background-color="#d9f5ff" start-indent="0pt">
															<fo:table-row>
																<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
																	<fo:block text-align="center">
																		<fo:inline>
																			<xsl:text>Entity Name</xsl:text>
																		</fo:inline>
																	</fo:block>
																</fo:table-cell>
																<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" border-top-color="black" border-top-style="solid" border-top-width="thin" font-size="xx-small" padding="3" display-align="center">
																	<fo:block text-align="center">
																		<fo:inline>
																			<xsl:text>Attribute Name</xsl:text>
																		</fo:inline>
																	</fo:block>
																</fo:table-cell>
															</fo:table-row>
														</fo:table-header>
														<fo:table-body start-indent="0pt">
															<xsl:for-each select="n1:EntitiesCollection">
																<xsl:for-each select="n1:EntityDetails">
																	<fo:table-row>
																		<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-left-color="black" border-left-style="solid" border-left-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="before">
																			<fo:block text-align="left">
																				<xsl:choose>
																					<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																						<xsl:for-each select="n1:EntityName">
																							<altova:inline-container-substitute>
																								<xsl:apply-templates/>
																							</altova:inline-container-substitute>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																						<xsl:choose>
																							<xsl:when test="string-length(n1:EntityName) &gt; 0">
																								<xsl:for-each select="n1:EntityName">
																									<altova:inline-container-substitute>
																										<xsl:apply-templates/>
																									</altova:inline-container-substitute>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<fo:inline>
																									<xsl:text>&#160;</xsl:text>
																								</fo:inline>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																						<xsl:for-each select="n1:EntityName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																						<xsl:for-each select="n1:EntityName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																						<xsl:for-each select="n1:EntityName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																				</xsl:choose>
																			</fo:block>
																		</fo:table-cell>
																		<fo:table-cell border-bottom-color="black" border-bottom-style="solid" border-bottom-width="thin" border-right-color="black" border-right-style="solid" border-right-width="thin" font-size="xx-small" padding="3" display-align="before">
																			<fo:block text-align="left">
																				<xsl:choose>
																					<xsl:when test="$SV_OutputFormat = &apos;Authentic&apos;">
																						<xsl:for-each select="n1:AttributeName">
																							<altova:inline-container-substitute>
																								<xsl:apply-templates/>
																							</altova:inline-container-substitute>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;HTML&apos;">
																						<xsl:choose>
																							<xsl:when test="string-length(n1:AttributeName) &gt; 0">
																								<xsl:for-each select="n1:AttributeName">
																									<altova:inline-container-substitute>
																										<xsl:apply-templates/>
																									</altova:inline-container-substitute>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<fo:inline>
																									<xsl:text>&#160;</xsl:text>
																								</fo:inline>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;RTF&apos;">
																						<xsl:for-each select="n1:AttributeName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;PDF&apos;">
																						<xsl:for-each select="n1:AttributeName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:when test="$SV_OutputFormat = &apos;Word2007&apos;">
																						<xsl:for-each select="n1:AttributeName">
																							<fo:inline>
																								<xsl:value-of select="string-join(for $i in 1 to string-length(.) return substring(.,$i,1),codepoints-to-string(8203))"/>
																							</fo:inline>
																							<fo:inline>
																								<xsl:text>s</xsl:text>
																							</fo:inline>
																						</xsl:for-each>
																					</xsl:when>
																				</xsl:choose>
																			</fo:block>
																		</fo:table-cell>
																	</fo:table-row>
																</xsl:for-each>
															</xsl:for-each>
														</fo:table-body>
													</fo:table>
												</xsl:variable>
												<xsl:apply-templates select="$altova:table" mode="altova:copy-table"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</fo:block>
						<fo:block id="SV_RefID_PageTotal"/>
					</fo:flow>
				</fo:page-sequence>
			</fo:root>
		</altova:main-document>
	</xsl:variable>
	<xsl:template name="altova:double-backslash">
		<xsl:param name="text"/>
		<xsl:param name="text-length"/>
		<xsl:variable name="text-after-bs" select="substring-after($text, '\')"/>
		<xsl:variable name="text-after-bs-length" select="string-length($text-after-bs)"/>
		<xsl:choose>
			<xsl:when test="$text-after-bs-length = 0">
				<xsl:choose>
					<xsl:when test="substring($text, $text-length) = '\'">
						<xsl:value-of select="concat(substring($text,1,$text-length - 1), '\\')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$text"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="concat(substring($text,1,$text-length - $text-after-bs-length - 1), '\\')"/>
				<xsl:call-template name="altova:double-backslash">
					<xsl:with-param name="text" select="$text-after-bs"/>
					<xsl:with-param name="text-length" select="$text-after-bs-length"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="altova:MakeValueAbsoluteIfPixels">
		<xsl:param name="sValue"/>
		<xsl:variable name="sBeforePx" select="substring-before($sValue, 'px')"/>
		<xsl:choose>
			<xsl:when test="$sBeforePx">
				<xsl:variable name="nLengthOfInteger">
					<xsl:call-template name="altova:GetCharCountOfIntegerAtEndOfString">
						<xsl:with-param name="sText" select="$sBeforePx"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="nPosOfInteger" select="string-length($sBeforePx) - $nLengthOfInteger + 1"/>
				<xsl:variable name="nValuePx" select="substring($sBeforePx, $nPosOfInteger)"/>
				<xsl:variable name="nValueIn" select="number($nValuePx) div number($altova:nPxPerIn)"/>
				<xsl:variable name="nLengthBeforeInteger" select="string-length($sBeforePx) - $nLengthOfInteger"/>
				<xsl:variable name="sRest">
					<xsl:call-template name="altova:MakeValueAbsoluteIfPixels">
						<xsl:with-param name="sValue" select="substring-after($sValue, 'px')"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:value-of select="concat(substring($sBeforePx, 1, $nLengthBeforeInteger), string($nValueIn), 'in', $sRest)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$sValue"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="altova:GetCharCountOfIntegerAtEndOfString">
		<xsl:param name="sText"/>
		<xsl:variable name="sLen" select="string-length($sText)"/>
		<xsl:variable name="cLast" select="substring($sText, $sLen)"/>
		<xsl:choose>
			<xsl:when test="number($cLast) &gt;= 0 and number($cLast) &lt;= 9">
				<xsl:variable name="nResultOfRest">
					<xsl:call-template name="altova:GetCharCountOfIntegerAtEndOfString">
						<xsl:with-param name="sText" select="substring($sText, 1, $sLen - 1)"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:value-of select="$nResultOfRest + 1"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>0</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:copy-table">
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:table" mode="altova:copy-table">
		<xsl:choose>
			<xsl:when test="(empty(fo:table-body/fo:table-row) and empty(fo:table-header/fo:table-row) and empty(fo:table-footer/fo:table-row)) or empty(.//fo:table-cell)">				</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="fo:table-header | fo:table-footer" mode="altova:copy-table">
		<xsl:choose>
			<xsl:when test="empty(fo:table-row)">				</xsl:when>
			<xsl:otherwise>
				<xsl:copy-of select="."/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="fo:table-body" mode="altova:copy-table">
		<xsl:choose>
			<xsl:when test="empty(fo:table-row)">
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
					<fo:table-row>
						<fo:table-cell>
							<fo:block/>
						</fo:table-cell>
					</fo:table-row>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy-of select="."/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="altova:pdf-bookmark-tree[@generate-from-toc = false()]" mode="second-step">
		<xsl:variable name="altova:pdf-bookmarks">
			<xsl:apply-templates mode="altova:filter-pdf-bookmark-tree"/>
		</xsl:variable>
		<xsl:if test="exists($altova:pdf-bookmarks/fo:bookmark)">
			<fo:bookmark-tree>
				<xsl:copy-of select="$altova:pdf-bookmarks"/>
			</fo:bookmark-tree>
		</xsl:if>
	</xsl:template>
	<xsl:template match="node()" mode="altova:filter-pdf-bookmark-tree">
		<xsl:apply-templates mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:pdf-bookmark" mode="altova:filter-pdf-bookmark-tree">
		<fo:bookmark>
			<xsl:sequence select="@starting-state"/>
			<xsl:variable name="altova:hyperlink" select="altova:hyperlink[1]"/>
			<xsl:choose>
				<xsl:when test="not(exists($altova:hyperlink))">
					<xsl:message select="'Error: Found PDF bookmark without a corresponding hyperlink!'" terminate="yes"/>
					<xsl:attribute name="internal-destination" select="'undefined'"/>
					<fo:bookmark-title/>
				</xsl:when>
				<xsl:when test="not(starts-with($altova:hyperlink/@href,'#'))">
					<xsl:message select="concat('Error: External bookmark destinations (',$altova:hyperlink/@href,') are not supported by FOP 0.93/1.0!')" terminate="yes"/>
					<xsl:attribute name="internal-destination" select="'external-destination-not-supported'"/>
					<fo:bookmark-title>
						<xsl:sequence select="$altova:hyperlink//@color[1] | $altova:hyperlink//@font-style[.='normal' or .='italic'][1] | $altova:hyperlink//@font-weight[.='normal' or .='bold'][1]"/>
						<xsl:value-of select="string($altova:hyperlink)"/>
					</fo:bookmark-title>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="altova:bookmark-name" select="substring($altova:hyperlink/@href,2)"/>
					<xsl:variable name="altova:source-document" select="ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
					<xsl:variable name="altova:target-document" select="key('altova:bookmark-key',$altova:bookmark-name,$altova:design-xslt-tree-view)[1]/ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
					<xsl:choose>
						<xsl:when test="empty($altova:target-document) or $altova:source-document is $altova:target-document">
							<xsl:attribute name="internal-destination" select="$altova:bookmark-name"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:variable name="altova:relative-path" select="altova:calc-relative-path($altova:source-document/@url,$altova:target-document/@url)"/>
							<xsl:variable name="altova:url" select="concat(substring($altova:relative-path,1,string-length($altova:relative-path) - 3),'.pdf#dest=',$altova:bookmark-name)"/>
							<xsl:message select="concat('Warning: External bookmark destinations (',$altova:url,') are not supported by FOP 0.93/1.0!')"/>
							<xsl:attribute name="internal-destination" select="'external-destination-not-supported'"/>
						</xsl:otherwise>
					</xsl:choose>
					<fo:bookmark-title>
						<xsl:sequence select="$altova:hyperlink//@color[1] | $altova:hyperlink//@font-style[.='normal' or .='italic'][1] | $altova:hyperlink//@font-weight[.='normal' or .='bold'][1]"/>
						<xsl:value-of select="string($altova:hyperlink)"/>
					</fo:bookmark-title>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="count(altova:hyperlink) gt 1">
				<xsl:message select="concat('Error: Found PDF bookmark (',$altova:hyperlink/@href,') with more than one corresponding hyperlinks!')" terminate="yes"/>
			</xsl:if>
			<xsl:apply-templates mode="#current"/>
		</fo:bookmark>
	</xsl:template>
	<xsl:template match="fo:basic-link" mode="second-step">
		<xsl:choose>
			<xsl:when test="count(node()) eq 1 and fo:block">
				<fo:block>
					<xsl:apply-templates select="fo:block[1]/@*" mode="#current"/>
					<fo:basic-link>
						<xsl:apply-templates select="@*" mode="#current"/>
						<xsl:apply-templates select="fo:block[1]/node()" mode="#current"/>
					</fo:basic-link>
				</fo:block>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="altova:is-node-empty" as="xs:boolean">
		<xsl:param name="altova:node" as="element()"/>
		<xsl:sequence select="every $altova:child in $altova:node/child::node() satisfies ( ( boolean( $altova:child/self::text() ) and string-length( $altova:child ) = 0 ) or ( ( boolean( $altova:child/self::altova:inline-container-substitute ) or boolean( $altova:child/self::fo:inline ) or boolean( $altova:child/self::fo:inline-container ) or boolean( $altova:child/self::fo:block ) or boolean( $altova:child/self::fo:basic-link ) ) and altova:is-node-empty( $altova:child ) ) )"/>
	</xsl:function>
	<xsl:template match="/">
		<xsl:variable name="altova:design-xslt-tree-output-without-document-sections">
			<xsl:apply-templates select="$altova:design-xslt-tree-view" mode="second-step"/>
		</xsl:variable>
		<xsl:apply-templates select="$altova:design-xslt-tree-output-without-document-sections" mode="altova:generate-document-sections"/>
		<xsl:for-each select="$altova:design-xslt-tree-output-without-document-sections//altova:result-document">
			<xsl:result-document href="{@url}">
				<xsl:apply-templates mode="altova:generate-document-sections"/>
			</xsl:result-document>
		</xsl:for-each>
		<xsl:for-each select="$altova:design-xslt-tree-output-without-document-sections//fo:external-graphic[exists(@altova:ImageDataBase64)]">
			<xsl:result-document href="{@altova:target-url}" method="text" encoding="base64tobinary">
				<xsl:value-of select="@altova:ImageDataBase64"/>
			</xsl:result-document>
		</xsl:for-each>
		<xsl:if test="$altova:bGeneratingFromPxf">
			<xsl:for-each select="distinct-values(for $i in $altova:design-xslt-tree-output-without-document-sections//fo:external-graphic[not(@altova:ImageDataBase64)]/@src return lower-case($i))">
				<xsl:variable name="altova:sSrcUrl" select="if (starts-with(., 'url(') and ends-with(., ')')) then substring(., 5, string-length(.) - 5) else ."/>
				<xsl:if test="not(starts-with($altova:sSrcUrl, 'http://') or starts-with($altova:sSrcUrl, 'ftp://'))">
					<xsl:if test="unparsed-text-available($altova:sSrcUrl, 'binarytobase64')">
						<xsl:result-document href="{$altova:sSrcUrl}" method="text" encoding="base64tobinary">
							<xsl:value-of select="unparsed-text($altova:sSrcUrl, 'binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:generate-document-sections altova:generate-document-section-copy">
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="altova:document-section" mode="altova:generate-document-section-copy">			</xsl:template>
	<xsl:template match="fo:page-sequence" mode="altova:generate-document-sections">
		<xsl:variable name="altova:page-sequence" select="."/>
		<!-- All secondary document sections -->
		<xsl:variable name="altova:document-sections" select="$altova:page-sequence//altova:document-section except $altova:page-sequence//altova:result-document//altova:document-section"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="(@* except @altova:*)" mode="#current"/>
			<!--					The initial document section has an even or odd number of pages depending on where the first secondary one starts					(there is at least one secondary document section, or we wouldn't be in this template					-->
			<xsl:choose>
				<xsl:when test="$altova:document-sections[1]/@altova:section-starts-on = 'even'">
					<xsl:attribute name="force-page-count" select="'end-on-odd'"/>
				</xsl:when>
				<xsl:when test="$altova:document-sections[1]/@altova:section-starts-on = 'odd'">
					<xsl:attribute name="force-page-count" select="'end-on-even'"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="force-page-count" select="'no-force'"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:apply-templates select="(node() except fo:flow[@flow-name='xsl-region-body'])" mode="#current"/>
			<xsl:apply-templates select="fo:flow[@flow-name='xsl-region-body']" mode="altova:generate-document-section-default">
				<xsl:with-param name="altova:document-section-path" select="$altova:document-sections[ 1 ]/ancestor-or-self::node()"/>
			</xsl:apply-templates>
		</xsl:copy>
		<!-- Generate a page sequence for each secondary document section -->
		<xsl:for-each select="$altova:document-sections">
			<xsl:variable name="altova:document-section-index" select="position()"/>
			<fo:page-sequence>
				<xsl:apply-templates select="(@* except @altova:*)" mode="#current"/>
				<xsl:choose>
					<!-- If it's the last document section -->
					<xsl:when test="position() = last()">
						<!-- The secondary document section has even or odd number of pages depending on the document-wide setting -->
						<xsl:choose>
							<xsl:when test="$altova:page-sequence/@altova:DocumentEndsOn = 'even'">
								<xsl:attribute name="force-page-count" select="'end-on-even'"/>
							</xsl:when>
							<xsl:when test="$altova:page-sequence/@altova:DocumentEndsOn = 'odd'">
								<xsl:attribute name="force-page-count" select="'end-on-odd'"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:attribute name="force-page-count" select="'no-force'"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<!-- The secondary document section has an even or odd number of pages depending on where the next one starts -->
						<xsl:choose>
							<xsl:when test="$altova:document-sections[$altova:document-section-index + 1]/@altova:section-starts-on = 'even'">
								<xsl:attribute name="force-page-count" select="'end-on-odd'"/>
							</xsl:when>
							<xsl:when test="$altova:document-sections[$altova:document-section-index + 1]/@altova:section-starts-on = 'odd'">
								<xsl:attribute name="force-page-count" select="'end-on-even'"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:attribute name="force-page-count" select="'no-force'"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:apply-templates select="node()" mode="#current"/>
				<xsl:choose>
					<xsl:when test="position()=last()">
						<xsl:apply-templates select="$altova:page-sequence/fo:flow[@flow-name='xsl-region-body']" mode="altova:generate-document-section-last">
							<xsl:with-param name="altova:document-section-path" select="current()/ancestor-or-self::node()"/>
						</xsl:apply-templates>
					</xsl:when>
					<xsl:otherwise>
						<xsl:variable name="altova:document-section-position" select="position()"/>
						<xsl:apply-templates select="$altova:page-sequence/fo:flow[@flow-name='xsl-region-body']" mode="altova:generate-document-section">
							<xsl:with-param name="altova:document-section-path" select="current()/ancestor-or-self::node()"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:document-sections[$altova:document-section-position+1]/ancestor-or-self::node()"/>
						</xsl:apply-templates>
					</xsl:otherwise>
				</xsl:choose>
			</fo:page-sequence>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:generate-document-section">
		<xsl:param name="altova:document-section-path"/>
		<xsl:param name="altova:next-document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@*" mode="altova:generate-document-section-copy"/>
			<xsl:variable name="altova:first-node" select="node() intersect $altova:document-section-path"/>
			<xsl:variable name="altova:last-node" select="node() intersect $altova:next-document-section-path"/>
			<xsl:choose>
				<xsl:when test="$altova:first-node and ( $altova:first-node is $altova:last-node )">
					<xsl:if test="not($altova:first-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:first-node" mode="altova:generate-document-section">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$altova:first-node and $altova:last-node">
					<xsl:if test="not($altova:first-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:first-node" mode="altova:generate-document-section">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
					<xsl:apply-templates select="$altova:first-node/following-sibling::node()[ . &lt;&lt; $altova:last-node ]" mode="altova:generate-document-section-copy"/>
					<xsl:if test="not($altova:last-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:last-node" mode="altova:generate-document-section">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$altova:first-node">
					<xsl:if test="not($altova:first-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:first-node" mode="altova:generate-document-section">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
					<xsl:apply-templates select="$altova:first-node/following-sibling::node()" mode="altova:generate-document-section-copy"/>
				</xsl:when>
				<xsl:when test="$altova:last-node">
					<xsl:apply-templates select="$altova:last-node/preceding-sibling::node()" mode="altova:generate-document-section-copy"/>
					<xsl:if test="not($altova:last-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:last-node" mode="altova:generate-document-section">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:apply-templates select="node()" mode="altova:generate-document-section-copy"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:table" mode="altova:generate-document-section">
		<xsl:param name="altova:document-section-path"/>
		<xsl:param name="altova:next-document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@*" mode="altova:generate-document-section-copy"/>
			<xsl:if test="exists( $altova:next-document-section-path intersect current() )">
				<xsl:apply-templates select="fo:table-column" mode="altova:generate-document-sections"/>
			</xsl:if>
			<xsl:apply-templates select="(node() except altova:document-section)[ empty( following-sibling::node() intersect $altova:document-section-path ) and empty( preceding-sibling::node() intersect $altova:next-document-section-path ) ]" mode="#current">
				<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
				<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:table-row" mode="altova:generate-document-section">
		<xsl:param name="altova:document-section-path"/>
		<xsl:param name="altova:next-document-section-path"/>
		<xsl:if test="empty( $altova:next-document-section-path intersect current() )">
			<xsl:copy copy-namespaces="no">
				<xsl:choose>
					<xsl:when test="exists( $altova:document-section-path intersect current() )">
						<xsl:apply-templates select="@* | node()" mode="#current">
							<xsl:with-param name="altova:document-section-path" select="()"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:when>
					<xsl:otherwise>
						<xsl:apply-templates select="(node() except altova:document-section)[ empty( following-sibling::node() intersect $altova:document-section-path ) and empty( preceding-sibling::node() intersect $altova:next-document-section-path ) ]" mode="#current">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
							<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
						</xsl:apply-templates>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:copy>
		</xsl:if>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:generate-document-section-default">
		<xsl:param name="altova:document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@*" mode="altova:generate-document-section-copy"/>
			<xsl:variable name="altova:last-node" select="node() intersect $altova:document-section-path"/>
			<xsl:choose>
				<xsl:when test="$altova:last-node">
					<xsl:apply-templates select="$altova:last-node/preceding-sibling::node()" mode="altova:generate-document-section-copy"/>
					<xsl:if test="not($altova:last-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:last-node" mode="altova:generate-document-section-default">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:apply-templates select="node()" mode="altova:generate-document-section-copy"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:table-row" mode="altova:generate-document-section-default">
		<xsl:param name="altova:document-section-path"/>
		<xsl:if test="empty( $altova:document-section-path intersect current() )">
			<xsl:copy copy-namespaces="no">
				<xsl:apply-templates select="@* | ( node() except altova:document-section )" mode="altova:generate-document-section-copy"/>
			</xsl:copy>
		</xsl:if>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:generate-document-section-last">
		<xsl:param name="altova:document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@*" mode="altova:generate-document-section-copy"/>
			<xsl:variable name="altova:first-node" select="node() intersect $altova:document-section-path"/>
			<xsl:choose>
				<xsl:when test="$altova:first-node">
					<xsl:if test="not($altova:first-node/self::altova:document-section)">
						<xsl:apply-templates select="$altova:first-node" mode="altova:generate-document-section-last">
							<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
						</xsl:apply-templates>
					</xsl:if>
					<xsl:apply-templates select="$altova:first-node/following-sibling::node()" mode="altova:generate-document-section-copy"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:apply-templates select="node()" mode="altova:generate-document-section-copy"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:table" mode="altova:generate-document-section-last">
		<xsl:param name="altova:document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@*" mode="altova:generate-document-section-copy"/>
			<xsl:if test="exists( $altova:document-section-path intersect current() )">
				<xsl:apply-templates select="fo:table-column" mode="altova:generate-document-sections"/>
			</xsl:if>
			<xsl:apply-templates select="(node() except altova:document-section)[ empty( following-sibling::node() intersect $altova:document-section-path ) ]" mode="#current">
				<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:table-row" mode="altova:generate-document-section-last">
		<xsl:param name="altova:document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:choose>
				<xsl:when test="exists( $altova:document-section-path intersect current() )">
					<xsl:apply-templates select="@* | node()" mode="#current">
						<xsl:with-param name="altova:document-section-path" select="()"/>
					</xsl:apply-templates>
				</xsl:when>
				<xsl:otherwise>
					<xsl:apply-templates select="@* | (node() except altova:document-section)[ empty( following-sibling::node() intersect $altova:document-section-path ) ]" mode="#current">
						<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
					</xsl:apply-templates>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="fo:list-item" mode="altova:generate-document-section altova:generate-document-section-default altova:generate-document-section-last">
		<xsl:param name="altova:document-section-path"/>
		<xsl:param name="altova:next-document-section-path"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@*" mode="#current">
				<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
				<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
			</xsl:apply-templates>
			<xsl:apply-templates select="fo:list-item-label" mode="#current">
				<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
				<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
			</xsl:apply-templates>
			<xsl:apply-templates select="(node() except fo:list-item-label)" mode="#current">
				<xsl:with-param name="altova:document-section-path" select="$altova:document-section-path"/>
				<xsl:with-param name="altova:next-document-section-path" select="$altova:next-document-section-path"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="altova:result-document" mode="altova:generate-document-section altova:generate-document-section-copy altova:generate-document-section-default altova:generate-document-section-last">			</xsl:template>
	<xsl:template match="altova:bookmark" mode="second-step">
		<xsl:variable name="bookmark-content">
			<altova:bookmark>
				<xsl:apply-templates select="node()" mode="#current"/>
			</altova:bookmark>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="altova:is-node-empty($bookmark-content/altova:bookmark)">
				<fo:block>
					<xsl:apply-templates select="@*" mode="#current"/>
					<xsl:copy-of select="$bookmark-content/altova:bookmark/node()"/>
				</fo:block>
			</xsl:when>
			<xsl:otherwise>
				<fo:inline>
					<xsl:apply-templates select="@*" mode="#current"/>
					<xsl:copy-of select="$bookmark-content/altova:bookmark/node()"/>
				</fo:inline>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:key name="altova:bookmark-key" match="altova:bookmark" use="@name"/>
	<xsl:template match="altova:bookmark/@name" mode="second-step">
		<xsl:attribute name="id" select="."/>
	</xsl:template>
	<xsl:template match="altova:hyperlink" mode="second-step">
		<fo:basic-link>
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</fo:basic-link>
	</xsl:template>
	<xsl:template match="altova:hyperlink/@href" mode="second-step">
		<xsl:choose>
			<xsl:when test="not(string(.))">
				<xsl:attribute name="external-destination" select="'url()'"/>
			</xsl:when>
			<xsl:when test="starts-with(.,'#')">
				<xsl:variable name="altova:bookmark-name" select="substring(.,2)"/>
				<xsl:variable name="altova:source-document" select="ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
				<xsl:variable name="altova:target-document" select="key('altova:bookmark-key',$altova:bookmark-name,$altova:design-xslt-tree-view)[1]/ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
				<xsl:choose>
					<xsl:when test="empty($altova:target-document) or $altova:source-document is $altova:target-document">
						<xsl:attribute name="internal-destination" select="$altova:bookmark-name"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:variable name="altova:relative-path" select="altova:calc-relative-path($altova:source-document/@url,$altova:target-document/@url)"/>
						<xsl:variable name="altova:url" select="concat(substring($altova:relative-path,1,string-length($altova:relative-path) - 3),'.pdf#dest=',$altova:bookmark-name)"/>
						<xsl:variable name="altova:escaped-url">
							<xsl:call-template name="altova:double-backslash">
								<xsl:with-param name="text" select="$altova:url"/>
								<xsl:with-param name="text-length" select="string-length($altova:url)"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:attribute name="external-destination" select="concat('url(',$altova:escaped-url,')')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:escaped-url">
					<xsl:choose>
						<xsl:when test="starts-with(.,'\\') or substring(.,2,1)=':'">
							<xsl:value-of select="iri-to-uri(concat('file:///',translate(.,'\','/')))"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="iri-to-uri(.)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:attribute name="external-destination" select="concat('url(',$altova:escaped-url,')')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="altova:inline-container-substitute" mode="second-step">
		<xsl:choose>
			<xsl:when test="empty(for $i in child::node() return index-of(('fo:block', 'fo:block-container', 'fo:list-block', 'fo:table'), name($i))) or name(../..) eq 'fo:list-item-body'">
				<fo:inline>
					<xsl:copy-of select="@* except @altova-DisableOutputEscaping"/>
					<xsl:apply-templates mode="second-step"/>
				</fo:inline>
			</xsl:when>
			<xsl:otherwise>
				<fo:block>
					<xsl:copy-of select="@* except @altova-DisableOutputEscaping"/>
					<xsl:apply-templates mode="second-step"/>
				</fo:block>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="altova:main-document" mode="second-step">
		<xsl:apply-templates mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:basic-link-container" mode="second-step">
		<fo:block text-align-last="justify">
			<xsl:apply-templates mode="second-step"/>
		</fo:block>
	</xsl:template>
	<xsl:template match="altova:newline-handler" mode="second-step">
		<xsl:variable name="name-following-sibling" select="name(following-sibling::*[1])"/>
		<xsl:variable name="name-preceding-sibling" select="name(preceding-sibling::*[1])"/>
		<xsl:if test="($name-following-sibling and $name-following-sibling != 'fo:table' and $name-following-sibling != 'altova:newline-handler' and $name-preceding-sibling != 'altova:basic-link-container') or $name-preceding-sibling = 'altova:newline-handler'">
			<fo:block>
				<xsl:if test="($name-preceding-sibling != 'altova:inline-container-substitute' and $name-preceding-sibling != 'fo:inline' and $name-preceding-sibling != 'fo:basic-link' and $name-preceding-sibling != 'altova:bookmark' and $name-preceding-sibling != 'altova:hyperlink') or ($name-following-sibling != 'altova:inline-container-substitute' and $name-following-sibling != 'fo:inline' and $name-following-sibling != 'fo:basic-link' and $name-following-sibling != 'altova:bookmark' and $name-following-sibling != 'altova:hyperlink')">
					<fo:leader leader-pattern="space"/>
				</xsl:if>
			</fo:block>
		</xsl:if>
	</xsl:template>
	<xsl:function name="altova:calc-relative-path" as="xs:string">
		<xsl:param name="altova:source-path"/>
		<xsl:param name="altova:target-path"/>
		<xsl:choose>
			<xsl:when test="$altova:source-path = $altova:target-path">
				<xsl:sequence select="''"/>
			</xsl:when>
			<xsl:when test="starts-with($altova:target-path,'http:') or starts-with($altova:target-path,'ftp:') or starts-with($altova:target-path,'file:')">
				<xsl:sequence select="$altova:target-path"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:source-parts" select="tokenize($altova:source-path,'[/\\]')"/>
				<xsl:variable name="altova:target-parts" select="tokenize($altova:target-path,'[/\\]')"/>
				<xsl:variable name="altova:common-part-count" select="sum(for $i in (1 to count($altova:source-parts) - 1) return if( subsequence($altova:source-parts,1,$i) = subsequence($altova:target-parts,1,$i) ) then 1 else 0)"/>
				<xsl:sequence select="string-join((for $i in ($altova:common-part-count + 1 to count($altova:source-parts) - 1) return '..',for $i in ($altova:common-part-count + 1 to count($altova:target-parts)) return $altova:target-parts[$i]),'/')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:map-preview-filepath" as="xs:string">
		<xsl:param name="filepath"/>
		<xsl:sequence select="altovaext:create-temp-file-mapping($filepath)" use-when="function-available('altovaext:create-temp-file-mapping',1)"/>
		<xsl:sequence select="$filepath" use-when="not(function-available('altovaext:create-temp-file-mapping',1))"/>
	</xsl:function>
	<xsl:template match="*|@*|comment()|processing-instruction()" mode="second-step">
		<xsl:copy>
			<xsl:apply-templates select="node()|@* except @altova-DisableOutputEscaping" mode="second-step"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="text()" mode="second-step">
		<xsl:choose>
			<xsl:when test="../@altova-DisableOutputEscaping">
				<xsl:value-of select="." disable-output-escaping="yes"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="altova:number" mode="second-step">
		<xsl:number level="single" count="altova:dummy-list-item | fo:list-item" format="{@format}" from="fo:list-block"/>
	</xsl:template>
	<xsl:template match="altova:dummy-list-item" mode="second-step">		</xsl:template>
	<xsl:function name="altova:GetChartYValuesForSingleSeries">
		<xsl:param name="seqCategoryLeafPos" as="node()*"/>
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:for-each select="$seqCategoryLeafPos">
			<xsl:element name="altova:Value">
				<xsl:value-of select="altova:GetChartYValueForSingleSeriesPos($nodeSeriesLeafPos, ., $bValuesInCategory)"/>
			</xsl:element>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="altova:GetChartYValueForSingleSeriesPos">
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="nodeCategoryLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:variable name="altova:seqCategoryContextIds" select="$nodeCategoryLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:seqSeriesContextIds" select="$nodeSeriesLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:sCommonContextId" select="for $i in $altova:seqCategoryContextIds return if (some $j in $altova:seqSeriesContextIds satisfies $i eq $j) then $i else ()" as="xs:string*"/>
		<xsl:choose>
			<xsl:when test="count($altova:sCommonContextId) gt 1">
				<xsl:message select="concat('XBRL Chart: Error: Found several values instead of a single one (contexts: ', string-join($altova:sCommonContextId, ', '), ').')" terminate="yes"/>
			</xsl:when>
			<xsl:when test="count($altova:sCommonContextId) lt 1">
				<xsl:message select="concat('XBRL Chart: Info: No value found for position labeled &quot;', $nodeCategoryLeafPos/@altova:sLabel, '&quot;')" terminate="no"/>
				<xsl:sequence select="'altova:no-value'"/>
			</xsl:when>
			<xsl:when test="$bValuesInCategory">
				<xsl:sequence select="xs:string($nodeCategoryLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="xs:string($nodeSeriesLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartLabelForPos" as="xs:string">
		<xsl:param name="nodeParam" as="node()"/>
		<xsl:value-of select="string-join($nodeParam/ancestor-or-self::altova:Pos/@altova:sLabel, ' ')"/>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-pixel" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="substring-before($normLength, 'px')"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * $altova:nPxPerIn"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * $altova:nPxPerIn div 2.54"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'mm')) * $altova:nPxPerIn div 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * $altova:nPxPerIn div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * $altova:nPxPerIn div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$normLength"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-mm" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'px')) div $altova:nPxPerIn * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * 10"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="substring-before($normLength, 'mm') "/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * 25.4 div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * 25.4 div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="number($normLength) div $altova:nPxPerIn * 25.4"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
</xsl:stylesheet>
